[{"categories":null,"content":" 安装protobuf 源码安装: https://zhuanlan.zhihu.com/p/60471892 # 下载 https://github.com/protocolbuffers/protobuf/releases # 选择 protobuf-all-3.17.3.tar.gz # 解压 # 设置编译目录 $ ./configure --prefix=/usr/local/protobuf # 安装 $ make $ make install # 配置环境变量 .zshrc, 添加: # export PROTOBUF=/usr/local/protobuf # export PATH=$PROTOBUF/bin:$PATH $ source ~/.zshrc $ protoc --version libprotoc 3.17.3 安装protoc的Go插件 go get -u github.com/golang/protobuf/protoc-gen-go # 配置环境变量 # .zshrc $ export PATH=\"$PATH:$(go env GOPATH)/bin\" 安装go-grpc包 $ go get -u google.golang.org/grpc ","date":"2021-08-08","objectID":"/installation/:0:0","tags":null,"title":"mac go grpc环境准备","uri":"/installation/"},{"categories":null,"content":"区别 方法 语法 \u003e \u003c（大于，小于）查询 AND, OR查询 filter 类名.用属性名，比较用= 支持 支持 filter_by 直接用属性名，比较用== 支持 支持 ","date":"2021-08-07","objectID":"/filter_by/:1:0","tags":null,"title":"sqlalchemy filter和filter_by区别","uri":"/filter_by/"},{"categories":null,"content":"Examples # filter db.session.query(UserInfo.id).filter(UserInfo.id='1001').first() db.session.query(UserInfo.id).filter(UserInfo.id='1001', UserInfo.name='chen').first() # filter_by db.session.query(UserInfo.id).filter_by(id=='1001').first() db.session.query(UserInfo.id).filter(id='1001', name='chen').first() ","date":"2021-08-07","objectID":"/filter_by/:2:0","tags":null,"title":"sqlalchemy filter和filter_by区别","uri":"/filter_by/"},{"categories":null,"content":"在go中，main函数不会主动阻塞等待协程函数执行结束，类似默认调用了 C 中的 detach() 函数 package main import ( \"fmt\" \"time\" ) func main() { for i := 0; i \u003c 10; i++ { go func(i int) { time.Sleep(1 * time.Second) fmt.Println(i) }(i) } fmt.Println(\"main exit\") } 结果只会在控制台输出: main exit \\ 而想要实现类 C 语言中的 join() 函数, 通常有两种办法。 一种是通过channel进行同步 package main import ( \"fmt\" \"time\" ) func main() { ch := make(chan int, 2) go func() { for i := 0; i \u003c 10; i++ { time.Sleep(1 * time.Second) fmt.Println(\"go routine1\", i) } ch \u003c- 1 }() go func() { for i := 0; i \u003c 10; i++ { time.Sleep(1 * time.Second) fmt.Println(\"go routine2\", i) } ch \u003c- 2 }() // 等待 for i := 0; i \u003c 2; i++ { \u003c-ch } fmt.Println(\"main exist\") } \u0008这种方法需要知道子 goroutine 的个数 另一种办法是用 sync.WaitGroup，这\u0008种方法不需要知道 gotoutine 的个数 package main import ( \"fmt\" \"sync\" \"time\" ) func main() { var wg sync.WaitGroup for i := 0; i \u003c 10; i++ { wg.Add(1) go func(i int) { defer wg.Done() time.Sleep(1 * time.Second) fmt.Println(i) }(i) } wg.Wait() // 等待 fmt.Println(\"main exist\") } 推荐使用\u0008第二种写法，比较灵活; ","date":"2021-08-07","objectID":"/goroutine_join/:0:0","tags":null,"title":"go main函数等待所有goroutine结束","uri":"/goroutine_join/"},{"categories":null,"content":"mysqldump -h server address, localhost default -t table -d –no-data, 不导出数据, 仅导出表结构 ","date":"2021-06-10","objectID":"/dump/:0:0","tags":null,"title":"mysqldump导出数据","uri":"/dump/"},{"categories":null,"content":"只导出表结构，不导出数据 mysqldump -uroot -p123 -d test_database \u003e output.sql ","date":"2021-06-10","objectID":"/dump/:0:1","tags":null,"title":"mysqldump导出数据","uri":"/dump/"},{"categories":null,"content":"只导出表数据，不导出结构 mysqldump -uroot -p123 -t test_database \u003e output.sql ","date":"2021-06-10","objectID":"/dump/:0:2","tags":null,"title":"mysqldump导出数据","uri":"/dump/"},{"categories":null,"content":"导出整个数据库，表结构\u0026数据 mysqldump -uroot -p123 test_database \u003e output.sql ","date":"2021-06-10","objectID":"/dump/:0:3","tags":null,"title":"mysqldump导出数据","uri":"/dump/"},{"categories":null,"content":"导出单个数据表结构（不包含数据） mysqldump -uroot -p123 -d test_database test_tbl \u003e output.sql ","date":"2021-06-10","objectID":"/dump/:0:4","tags":null,"title":"mysqldump导出数据","uri":"/dump/"},{"categories":null,"content":"导出单个表数据（不包含结构） mysqldump -uroot -p123 -t test_database test_tbl \u003e output.sql ","date":"2021-06-10","objectID":"/dump/:0:5","tags":null,"title":"mysqldump导出数据","uri":"/dump/"},{"categories":null,"content":"导出单个表 (表结构\u0026表数据) mysqldump -uroot -p123 test_database test_tbl \u003e output.sql ","date":"2021-06-10","objectID":"/dump/:0:6","tags":null,"title":"mysqldump导出数据","uri":"/dump/"},{"categories":null,"content":"开发过程中常常需要将宿主机的文件拷贝到docker容器中，或将docker容器中的文件拷贝出来到宿主机。 ","date":"2021-06-10","objectID":"/copy_file/:0:0","tags":null,"title":"docker容器和宿主机之间相互拷贝文件","uri":"/copy_file/"},{"categories":null,"content":"拷贝到docker容器 docker cp file_name container_name:/tmp 比如将文件a.txt拷贝到mysql容器下的tmp目录 docker cp a.txt mysql:/tmp 进入docker容器查看是否拷贝成功 docker exec -it mysql /bin/bash cd /tmp ls ","date":"2021-06-10","objectID":"/copy_file/:1:0","tags":null,"title":"docker容器和宿主机之间相互拷贝文件","uri":"/copy_file/"},{"categories":null,"content":"拷贝到宿主机 只需要反过来写即可 docker cp container_name:/xxx/filename . 比如将mysql容器中/tmp/b.txt拷贝到宿主机当前文件 docker cp mysql:/tmp/b.txt . ls命令查看是否拷贝成功 拷贝文件夹不需要 -r 参数, 依然使用 docker cp ","date":"2021-06-10","objectID":"/copy_file/:2:0","tags":null,"title":"docker容器和宿主机之间相互拷贝文件","uri":"/copy_file/"},{"categories":null,"content":"system: Centos 7 装好centos之后，为了方便下载一些软件，常常需要更换yum源 默认的yum源配置在 /etc/yum.repos.d/CentOS-Base.repo中 [base] name=CentOS-$releasever - Base mirrorlist=http://mirrorlist.centos.org/?release=$releasever\u0026arch=$basearch\u0026repo=os\u0026infra=$infra #baseurl=http://mirror.centos.org/centos/$releasever/os/$basearch/ gpgcheck=1 gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7 更换阿里源 ","date":"2021-05-29","objectID":"/change-yum-repo/:0:0","tags":null,"title":"修改centos7 yum源","uri":"/change-yum-repo/"},{"categories":null,"content":"备份默认的yum源 mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup ","date":"2021-05-29","objectID":"/change-yum-repo/:1:0","tags":null,"title":"修改centos7 yum源","uri":"/change-yum-repo/"},{"categories":null,"content":"下载阿里源 wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo 阿里源配置: [base] name=CentOS-$releasever - Base - mirrors.aliyun.com failovermethod=priority baseurl=http://mirrors.aliyun.com/centos/$releasever/os/$basearch/ http://mirrors.aliyuncs.com/centos/$releasever/os/$basearch/ http://mirrors.cloud.aliyuncs.com/centos/$releasever/os/$basearch/ gpgcheck=1 gpgkey=http://mirrors.aliyun.com/centos/RPM-GPG-KEY-CentOS-**7** ","date":"2021-05-29","objectID":"/change-yum-repo/:2:0","tags":null,"title":"修改centos7 yum源","uri":"/change-yum-repo/"},{"categories":null,"content":"生成本地缓存 yum makecache yum makecache 是 将服务器上的软件包信息 现在本地缓存,以提高 搜索 安装软件的速度 更换源成功 ","date":"2021-05-29","objectID":"/change-yum-repo/:3:0","tags":null,"title":"修改centos7 yum源","uri":"/change-yum-repo/"},{"categories":null,"content":"查看当前源列表 sudo yum repo list ","date":"2021-05-29","objectID":"/change-yum-repo/:4:0","tags":null,"title":"修改centos7 yum源","uri":"/change-yum-repo/"},{"categories":null,"content":"about wget wget是一个下载文件的工具, 比如下载安装包: wget https://golang.org/dl/go1.16.4.linux-amd64.tar.gz 参数 -O –output-document=FILE下载文件保存为别的文件名 ","date":"2021-05-29","objectID":"/change-yum-repo/:5:0","tags":null,"title":"修改centos7 yum源","uri":"/change-yum-repo/"},{"categories":null,"content":"system: centos7 通过ssh连接远程虚拟机首先当前client安装了ssh, 使用 ssh -V 命令可以查看ssh版本 $ ssh -V OpenSSH_7.9p1, LibreSSL 2.7.3 ","date":"2021-05-27","objectID":"/ssh-connection/:0:0","tags":null,"title":"ssh连接远程虚拟机","uri":"/ssh-connection/"},{"categories":null,"content":"ping 通过ping命令目标虚拟机可以check网络是否联通 $ ping 10.211.55.3 PING 10.211.55.3 (10.211.55.3): 56 data bytes 64 bytes from 10.211.55.3: icmp_seq=0 ttl=64 time=0.217 ms 64 bytes from 10.211.55.3: icmp_seq=1 ttl=64 time=0.318 ms ^C ","date":"2021-05-27","objectID":"/ssh-connection/:1:0","tags":null,"title":"ssh连接远程虚拟机","uri":"/ssh-connection/"},{"categories":null,"content":"telnet 通过telnet命令check目标虚拟机对应端口是否开放, ssh默认端口是22 $ telnet 10.211.55.3 22 Trying 10.211.55.3... Connected to juzis-mbp.client.tw.trendnet.org. Escape character is '^]'. SSH-2.0-OpenSSH_7.9 ","date":"2021-05-27","objectID":"/ssh-connection/:2:0","tags":null,"title":"ssh连接远程虚拟机","uri":"/ssh-connection/"},{"categories":null,"content":"ssh 通过ssh连接 $ ssh jc@10.211.55.3 jc@10.211.55.3's password: 输入密码即可，如果目标虚拟机的ssh端口不是22, 需要带上参数 -p port_number 如果连接失败，出现connection reused, 需要在目标机器上排查: ","date":"2021-05-27","objectID":"/ssh-connection/:3:0","tags":null,"title":"ssh连接远程虚拟机","uri":"/ssh-connection/"},{"categories":null,"content":"1. sshd service是否active service sshd status 如果出现: Unit sshd.service could not be found 安装openssh-server sudo yum install openssh-server 然后启动sshd service: service sshd start 不启动的话 service status 是 inactive (dead) 启动之后: [jc@CentOS7 ~]$ service sshd status Redirecting to /bin/systemctl status sshd.service ● sshd.service - OpenSSH server daemon Loaded: loaded (/usr/lib/systemd/system/sshd.service; enabled; vendor preset: enabled) Active: active (running) since Sat 2021-05-29 09:48:53 CST; 24min ago Docs: man:sshd(8) man:sshd_config(5) Main PID: 1012 (sshd) CGroup: /system.slice/sshd.service └─1012 /usr/sbin/sshd -D 这是最常见的原因之一; ","date":"2021-05-27","objectID":"/ssh-connection/:3:1","tags":null,"title":"ssh连接远程虚拟机","uri":"/ssh-connection/"},{"categories":null,"content":"2. ssh端口号不是22 在目标机上查看 /etc/ssh/sshd_config中的Port值 如果连接失败提示permission不对，则可能需要修改/etc/ssh/sshd_config中的PubkeyAuthentication等参数； ","date":"2021-05-27","objectID":"/ssh-connection/:3:2","tags":null,"title":"ssh连接远程虚拟机","uri":"/ssh-connection/"},{"categories":null,"content":"添加Linux用户并为添加的用户授予root权限 System: Centos7 ","date":"2021-05-17","objectID":"/add-user-and-authorize/:0:0","tags":null,"title":"linux下添加用户并授权","uri":"/add-user-and-authorize/"},{"categories":null,"content":"添加用户rock adduser rock ","date":"2021-05-17","objectID":"/add-user-and-authorize/:1:0","tags":null,"title":"linux下添加用户并授权","uri":"/add-user-and-authorize/"},{"categories":null,"content":"修改用户密码 passwd rock ","date":"2021-05-17","objectID":"/add-user-and-authorize/:2:0","tags":null,"title":"linux下添加用户并授权","uri":"/add-user-and-authorize/"},{"categories":null,"content":"授权 因为个人用户只拥有当前home目录下的所有权限, 无法查看或修改其他用户目录。使用sudo可以获取到root权限。然而，新建的用户无法使用sudo命令，需要先对用户进行授权。 编辑 /etc/sudoers 文件 chmod -v u+w /etc/sudoers vim /etc/sudoers 在 root ALL=(ALL) ALL 下面加入一行 rock ALL=(ALL) ALL 后 wq 保存文件 如果你想要使用sudo的时候不需要密码，则加入 rock ALL=(ALL) NOPASSWD:ALL 收回sudoers的写权限 chmod -v u-w /etc/sudoers 退出并用新用户重新登陆， 此时新用户将可以使用 sudo 来获取root权限 ","date":"2021-05-17","objectID":"/add-user-and-authorize/:3:0","tags":null,"title":"linux下添加用户并授权","uri":"/add-user-and-authorize/"},{"categories":null,"content":"删除user userdel rock ","date":"2021-05-17","objectID":"/add-user-and-authorize/:4:0","tags":null,"title":"linux下添加用户并授权","uri":"/add-user-and-authorize/"},{"categories":null,"content":"关于chmod命令 全称: change mode, 用于控制用户对文件的权限 文件权限 -v: 显示权限变更的详细资料 -u 表示该文件的拥有者，g 表示与该文件的拥有者属于同一个群体(group)者，o 表示其他以外的人，a 表示这三者皆是。 + 表示增加权限、- 表示取消权限、= 表示唯一设定权限。 所以 u+w表示给文件拥有者加入写权限 ","date":"2021-05-17","objectID":"/add-user-and-authorize/:5:0","tags":null,"title":"linux下添加用户并授权","uri":"/add-user-and-authorize/"},{"categories":null,"content":"go语言不像python, 它是静态强类型语言, 在使用变量之前必须声明好类型。 在使用go net/http 发送 http 请求的时候，常常遇到请求所带的body是一个value类型不唯一的情况。比如有一个这样的request json body: { \"id\": 10, \"name\": \"jc\", \"groups\": [\"g1\", \"g2\"], \"info\": { \"address\": \"xxxx\", \"hobby\": [\"noodle\",\"sandwich\"], \"age\": 11 } } 在python中，没有类型要求，只需要一步一步写下去即可: import request # ... body = { \"id\": 10, \"name\": \"jc\", \"groups\": [\"g1\", \"g2\"], \"info\": { \"address\": \"xxxx\", \"hobby\": [\"noodle\",\"sandwich\"], \"age\": 11 } } resp = requests.post(url, headers=headers, data=json.dumps(body)) 但是在go中，必须将这样的body封装成一个固定类型的变量, 因为json body 中的value类型有int, string, list, map, 所以只能用interface{}作为body的value类型 var body map[string]interface{} =map[string]interface{} { \"id\": 10, \"name\":\"js\", \"groups\": []string{\"g1\",\"g2\"}, \"info\": map[string]interface{}{ \"address\":\"xxxx\", \"hobby\": []string{\"noodle\",\"sandwich\"}, \"age\":11, } } 然后将其作为变量传入函数: func send(body map[string]interface{}) error { bodyBytes, err := json.Marshal(body) // Marshal if err != nil { logs.Error(\"json Marshal fail.\") } reqBody := io.NopCloser(bytes.NewReader(bodyBytes)) // 构造 io.ReadCloser request := \u0026http.Request{ Method: \"POST\", URL: url, Header: map[string][]string{ \"Content-Type\": {\"application/json\"}, }, Body: reqBody, } resp, err := http.DefaultClient.Do(request) //... return nil } 这就是go中http body 格式比较复杂的封装方法 试试吧 ","date":"2021-05-08","objectID":"/go-post-request-body/:0:0","tags":null,"title":"go http请求中body的封装方法","uri":"/go-post-request-body/"},{"categories":null,"content":"Hugo是最流行的开源静态站点生成器之一。凭借其惊人的速度和灵活性，Hugo使构建网站变得非常简单。 ","date":"2021-05-07","objectID":"/setps-to-build-blog/:0:0","tags":null,"title":"使用hugo搭建blog","uri":"/setps-to-build-blog/"},{"categories":null,"content":"安装 hugo brew install hugo ","date":"2021-05-07","objectID":"/setps-to-build-blog/:1:0","tags":null,"title":"使用hugo搭建blog","uri":"/setps-to-build-blog/"},{"categories":null,"content":"新建一个blog网站 hugo new site blog ","date":"2021-05-07","objectID":"/setps-to-build-blog/:2:0","tags":null,"title":"使用hugo搭建blog","uri":"/setps-to-build-blog/"},{"categories":null,"content":"选择一个 Hugo 主题 访问 hugo 主题: https://themes.gohugo.io/ 选择一个主题， 比如 LoveIt: https://github.com/dillonzq/LoveIt git clone 至blog目录下 cd blog git clone https://github.com/dillonzq/LoveIt.git themes/LoveIt 编辑配置文件 config.toml refer: https://hugoloveit.com/zh-cn/theme-documentation-basics/#top ","date":"2021-05-07","objectID":"/setps-to-build-blog/:3:0","tags":null,"title":"使用hugo搭建blog","uri":"/setps-to-build-blog/"},{"categories":null,"content":"新建一篇文章 hugo new post/my-first-post.md 在文章中随便写点什么 ","date":"2021-05-07","objectID":"/setps-to-build-blog/:4:0","tags":null,"title":"使用hugo搭建blog","uri":"/setps-to-build-blog/"},{"categories":null,"content":"本地预览 hugo server -D 参数 -D, –buildDrafts include content marked as draft 打开网址 http://localhost:1313/ 即可查看本地生成的静态网站 ","date":"2021-05-07","objectID":"/setps-to-build-blog/:5:0","tags":null,"title":"使用hugo搭建blog","uri":"/setps-to-build-blog/"},{"categories":null,"content":"部署至 github 在github中新建一个repo: your_name.github.io, 注意your_name必须是你的 github 的 username 执行一下命令 git init git add --all git commit -m 'first commit' git remote add origin git@github.com:username/username.github.io.git git push -u origin master 登陆 https://your_github_name.github.io 查看效果 ","date":"2021-05-07","objectID":"/setps-to-build-blog/:6:0","tags":null,"title":"使用hugo搭建blog","uri":"/setps-to-build-blog/"},{"categories":null,"content":"An developer of backend focusing attention on Python and Go. ","date":"0001-01-01","objectID":"/about/:0:0","tags":null,"title":"","uri":"/about/"}]